---comandos de configuracion

$ git config [--options] user.name = "nombre"
$ git config [--options] user.email = "nombre@email.com"

--options

* system: almacena valores para todos los usuarios del sistema y todos sus repos
* global: especifico de un usuario
* local: configura en el repo que esten usando actualmente


$ git config --global user.name "nombreNuevo" --replace-all


$ git config --global --list


INICIALIZAR REPOSITORIOS


Existen 2 formas de comenzar a trabajar con un proyecto Git, una a partir de un proyecto
que ya exista en el remoto(Github-GitLab-etc) o si tenemos una carpeta local y queremos que se convierta en un repositorio git.


CASO 1: a partir de un repositorio en algun gestor remoto(Github-GitLab-etc) --> CLONAR

$ git clone url_repo
$ git clone https://github.com/achael/eht-imaging.git

CASO 2: ya existe una carpeta en mi maquina local

$ git init



GESTION DE ARCHIVOS

$ git status --> me indica si hay archivos untracked o no

$ git add nombre_archivo --> le damos la gestion del archivo a git
$ git add .		 --> idem anterior (muchos)

$ git restore nombre_archivo  --> vuelve el archivo al estado anterior
$ git restore .		      --> idem anterior (muchos)
$ git restore --staged nombre_archivo --> vuelve el archivo al stado untracked

Remover de Staging

$ git rm --cached nombre_archivo

Empaquetar cambios

$ git commit -m "descripcion o comentario" ---> empaquetar los archivos desde el area staging (que es la q gestiona git)


VER DIFERENCIAS

Luego de hacer un commit, si realizamos un cambio, los archivos vuelven a salir de la zona de staging

Cuando esta en este estado, podemos ver los cambios desde el ultimo commit

$ git diff

- En color rojo se ven las lineas modificadas (-)
- En color verde las lineas con cambios actuales (+)


VER Historial de cambios

$ git log // muestra todos los cambios (SHA-1, autor con el email, fecha, mensaje)
$ git log -n // muestra los ultimos n commits
$ git log --oneline // forma resumida
$ git log --oneline --graph --all

// Tambien podemos ver los cambios de un commit en particular

$ git show SHA-1 // alcanza con los primeros 6 digitos


RAMAS (Branches)

- una rama es simplemente un puntero movil que se√±ala un commit
- la rama por defecto de git es la rama master

Que es el puntero HEAD?

El puntero HEAD siempre apunta a la rama donde estoy actualmente. En el ejemplo vimos que apunta a master

Como puedo listar ramas?

$ git branch    // listado de ramas locales
$ git branch -a // listado de ramas locales y remotas

como creamos ramas?

git checkout nombre_rama   //  creo la rama pero que me quedo donde estoy parado

git checkout -b nombre_rama // creo la rama y me muevo a ella

como me muevo entre ramas?

con el comando checkout me muevo entre ramas( cambio a donde apunta el puntero HEAD)

git checkout nombre_rama

-------------------------------------------

Merge (Fusion)

Una de las ventajas es el uso de ramas para trabajar paralelamente, pero en algun momento la queremos
juntar(mezclar)

COMO UNIMOS LO QUE HICIMOS EN OTRAS RAMAS A LA RAMA PRINCIPAL

1. Creamos una rama basada en otra					$ git checkout -b rama
2- Trabajamos en la rama nueva
3- Guardamos los cambios (commit)					$ git commit -m "cambios2
4- Nos ubicamos en la rama donde queremos que los cambios se mezclen	$ git checkout master
5- Fusionamos los cambios						$ git merge rama
6- Podemos eliminar la rama ya "mergeada"				$ git branch -d rama

Que puede ocurrir al realizar "merge"?

Podemos tener conflictos o no.


- Casos donde No hay conflicto!


Merge "fast-forward" (avance rapido)

- Si no se realizo ningun commit en el master mientras hacia un commit en la rama.

Merge "no fast-forward"

- Si quiero que se cree un commit

$ git merge --no-ff nombre_rama

Merge "3-way" (a 3 bandas)

- Si la rama sufre cambios despues de haber creado la rama nueva, git realiza un merge a 3 bandas



- Que pasa cuando hay conflicto????

	* Ocurren un conflicto cuando se modifican las mismas lineas de codigo tanto en la rama original como en la nueva rama creada
	* Git avisa que se debe resolver el conflicto
	* Vamos a tener que elegir con que quedarnos:
		- dejar el contenido de la rama orginal
		- dejar el contenido de la rama nueva
		- dejar ambos contenidos
		- modificar lo necesario y creamos un nuevo contenido
	* Se guarda el archivo y se termina el merge
	* se guarda el archivo y se termina el merge (agregando a staging y haciendo un ultimo commit)



Repositorio Remoto

* La version del proyecto alojada en internet donde vamos a poder colaborar y agregar nuestros cambios

$ git remote  // los repositorios x defecto se llaman origin
origin 


$ git remote -v // esta opcion lista con mas detalle

origin URL_REPO (fetch o pull)
origin URL_REPO (push)

$  git remote show origin  // no muestas mas detalle del repo remoto y adonde apunta el HEAD

$ git remote add [nombre_repo] [URL]  // agregamos un repo remoto

$ git remote rm [nombre_repo]   	// eliminar un vinculo a repositorio remoto


Subir contenido local al repo remoto

$ git push [nombre_rep] [nombre_rama_local]
$ git push origin master


Como obtengo la informacion del repo remoto?

$ git fetch [nombre_repo]  // git fetch origin
$ git pull [nombre_repo]  // git pull origin

Si queremos trabajar con otra rama diferente a la rama base

$ git fetch origin nombre_rama_noBase

$ git pull origin nombre_rama_noBase


Cual es la diferencia entre fetch y pull

	* el fetch recupera todos los datos del repositorio en una carpeta oculta "origin/master"
	* Si quiero guardar los cambios tengo que hacer un merge
	* el comando pull realiza la misma descarga que fetch pero me agrega un merge automatico
	* git pull = git fetch + git merge

Clonacion a partir de una rama especifica

$ git clone --branch [nombre_rama] [URL_REPO]
